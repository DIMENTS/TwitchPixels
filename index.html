<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Twitch /Place - Community Pixel Art</title>
  <link rel="icon" href="/twitchpixelsico.png" type="image/x-icon">  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
    }

    #color-picker {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .color {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  cursor: pointer;
  border: 1px solid #c4c4c4; /* Light grey border */
  transition: border 0.2s;
}

    .color:hover,
    .color.selected {
      border-color: black;
    }

    #start-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10;
    text-align: center; /* Center de tekst horizontaal */
}

    #start-overlay h1 {
    font-size: 2em;
    margin-bottom: 20px;
}

    .twitch-purple {
    color: #9146FF; /* Twitch paars */
}

.place-offwhite {
    color: #F5F5F5; /* Off-white / bijna wit */
}

#start-overlay p {
    font-size: 1.2em;
    margin-bottom: 40px;
    padding: 0 20px;
    max-width: 840px; /* Maximale breedte van de tekst */
    line-height: 1.5; /* Voor betere leesbaarheid */
}

    #start-overlay button {
    padding: 15px 30px; /* Iets grotere padding */
    font-size: 1.2em;
    background: #F5F5F5; /* Off-white achtergrond */
    color: black; /* Zwarte tekst voor contrast */
    border: none;
    border-radius: 50px; /* Ronde knop */
    cursor: pointer;
    transition: background-color 0.3s ease; /* Soepele overgang bij hover */
}

#start-overlay button:hover {
    background: #E0E0E0; /* Iets donkerder off-white bij hover */
}

    #cooldown-indicator {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 1.2em;
      display: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="color-picker"></div>

  <div id="start-overlay">
    <h1>
        <span class="twitch-purple">Twitch</span>
        <span class="place-offwhite">/Place</span>!
    </h1>
    <p>
        Klik op een pixel om een kleur te plaatsen. Je moet 30 seconden wachten voordat je weer een pixel kunt plaatsen.
        Gebruik je muis of pijltjestoetsen om over de grid te navigeren. Zoom in en uit met je scrollwheel.
    </p>
    <button id="start-button">Start</button>
</div>

  <div id="cooldown-indicator">Cooldown: 30s</div>

  <script>
    const socket = new WebSocket('wss://tpwebsocket-production.up.railway.app');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startOverlay = document.getElementById('start-overlay');
    const startButton = document.getElementById('start-button');
    const overlayShownKey = 'startOverlayShown';
    const cooldownIndicator = document.getElementById('cooldown-indicator');
    const gridSize = 500;
    const cellSize = 10;
    
    const colors = [
    '#000000', // Zwart
    '#FFFFFF', // Wit (voor eventuele correcties)
    '#FF0000', // Rood
    '#00FF00', // Groen
    '#0000FF', // Blauw
    '#800000', // Bordeax
    '#00008B', // Donkerblauw
    '#FFFF00', // Geel
    ];
    
    let selectedColor = colors[0];

    const userId = Math.random().toString(36).substr(2, 9); // Voeg deze regel toe

    let grid = {};
    let activeUsers = {};
    let scale = 1, offsetX = 0, offsetY = 0;
    let isPanning = false, startX, startY;
    let cooldownActive = false;

    // Canvas grootte instellen
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Start Overlay Verwijderen
    startButton.addEventListener('click', () => {
      startOverlay.style.display = 'none';
    });

    if (localStorage.getItem(overlayShownKey) === 'true') {
            startOverlay.style.display = 'none'; // Verberg de overlay als deze al is getoond
            localStorage.setItem(overlayShownKey, 'true');
        }

    // Cooldown Indicator
    const startCooldown = (seconds) => {
  cooldownActive = true;
  cooldownIndicator.style.display = 'block';
  cooldownIndicator.textContent = `Cooldown: ${seconds}s`;
  let remaining = seconds;

  const interval = setInterval(() => {
    remaining--;
    cooldownIndicator.textContent = `Cooldown: ${remaining}s`;

    if (remaining <= 0) {
      clearInterval(interval);
      cooldownIndicator.style.display = 'none';
      cooldownActive = false;
    }
  }, 1000);
};


    // Grid tekenen
    const drawGrid = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }

      // Teken pixels
      Object.entries(grid).forEach(([key, color]) => {
        const [x, y] = key.split(',').map(Number);
        ctx.fillStyle = color;
        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
      });

      // Teken actieve muisindicaties
      Object.values(activeUsers).forEach(({ x, y }) => {
        ctx.beginPath();
        ctx.arc(x, y, 5 / scale, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fill();
      });

      ctx.restore();
    };

    drawGrid();

    // WebSocket handlers
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'init') {
        grid = data.grid;
        drawGrid();
      } else if (data.type === 'update_pixel') {
        const { x, y, color } = data;
        grid[`${x},${y}`] = color;
        drawGrid();
      } else if (data.type === 'mouse_move') {
        activeUsers[data.userId] = { x: data.x / scale - offsetX / scale, y: data.y / scale - offsetY / scale };
        drawGrid();
      }
    };

    // Plaats pixel
    canvas.addEventListener('click', (e) => {
  if (cooldownActive) return; // Blokkeer als de cooldown actief is

  const x = Math.floor((e.clientX - offsetX) / (cellSize * scale));
  const y = Math.floor((e.clientY - offsetY) / (cellSize * scale));

  // Verzend pixelplaatsing naar de server
  socket.send(JSON.stringify({
    type: 'place_pixel',
    userId,
    x,
    y,
    color: selectedColor,
  }));

  // Voeg de pixel lokaal toe aan de grid
  grid[`${x},${y}`] = selectedColor;
  drawGrid();

  // Start de cooldown-timer
  startCooldown(30);
});

// Voor touch ondersteuning
let lastTouchDistance = null;

canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    isPanning = true;
    startX = e.touches[0].clientX - offsetX;
    startY = e.touches[0].clientY - offsetY;
  } else if (e.touches.length === 2) {
    lastTouchDistance = getTouchDistance(e);
  }
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault(); // Voorkomt scrollen op mobiel
  if (e.touches.length === 1 && isPanning) {
    const touch = e.touches[0];
    offsetX = touch.clientX - startX;
    offsetY = touch.clientY - startY;
    drawGrid();
  } else if (e.touches.length === 2) {
    const newDistance = getTouchDistance(e);
    if (lastTouchDistance) {
      const delta = newDistance / lastTouchDistance;
      scale *= delta;
      scale = Math.min(Math.max(0.5, scale), 10); // Beperk de zoomfactor
      lastTouchDistance = newDistance;
      drawGrid();
    }
  }
});

canvas.addEventListener('touchend', (e) => {
  if (e.touches.length < 2) {
    lastTouchDistance = null;
  }
  isPanning = false;
});

// Helper functie om afstand tussen twee aanrakingen te berekenen
function getTouchDistance(e) {
  const dx = e.touches[0].clientX - e.touches[1].clientX;
  const dy = e.touches[0].clientY - e.touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// Responsive canvas aanpassen bij schermgrootte
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  drawGrid();
});



    // Muis beweging
    canvas.addEventListener('mousemove', (event) => {
      if (isPanning) {
        offsetX = event.clientX - startX;
        offsetY = event.clientY - startY;
        drawGrid();
      } else {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        socket.send(JSON.stringify({ type: 'move_mouse', userId, x, y }));
      }
    });

    canvas.addEventListener('mousedown', (event) => {
      isPanning = true;
      startX = event.clientX - offsetX;
      startY = event.clientY - offsetY;
    });

    canvas.addEventListener('mouseup', () => {
      isPanning = false;
    });

    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();
      scale += event.deltaY * -0.001;
      scale = Math.min(Math.max(0.5, scale), 4);
      drawGrid();
    });

    // Color picker
    const colorPicker = document.getElementById('color-picker');
    colors.forEach((color) => {
      const div = document.createElement('div');
      div.className = 'color';
      div.style.backgroundColor = color;

      if (color === selectedColor) div.classList.add('selected');

      div.addEventListener('click', () => {
        document.querySelectorAll('.color').forEach((el) => el.classList.remove('selected'));
        div.classList.add('selected');
        selectedColor = color;
      });

      colorPicker.appendChild(div);
    });
  </script>
</body>
</html>
