<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Twitch /Place - Community Pixel Art</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
    }

    #color-picker {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .color {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: border 0.2s;
    }

    .color:hover,
    .color.selected {
      border-color: black;
    }

    #start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    #start-overlay h1 {
      font-size: 2em;
      margin-bottom: 20px;
    }

    #start-overlay p {
      font-size: 1.2em;
      margin-bottom: 40px;
      text-align: center;
      padding: 0 20px;
    }

    #start-overlay button {
      padding: 10px 20px;
      font-size: 1em;
      background: #007BFF;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #start-overlay button:hover {
      background: #0056b3;
    }

    #cooldown-indicator {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 1.2em;
      display: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="color-picker"></div>

  <div id="start-overlay">
    <h1>Welkom bij Twitch r/place!</h1>
    <p>
      Klik op een pixel om een kleur te plaatsen. Je moet 30 seconden wachten voordat je weer een pixel kunt plaatsen.
      Gebruik je muis of pijltjestoetsen om over de grid te navigeren. Zoom in en uit met je scrollwheel.
    </p>
    <button id="start-button">Start</button>
  </div>

  <div id="cooldown-indicator">Cooldown: 30s</div>

  <script>
    const socket = new WebSocket('wss://twitch-pixels-jo80ch140-dimentss-projects.vercel.app');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startOverlay = document.getElementById('start-overlay');
    const startButton = document.getElementById('start-button');
    const cooldownIndicator = document.getElementById('cooldown-indicator');
    const gridSize = 1000;
    const cellSize = 10;
    const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#000000', '#FFFFFF'];
    let selectedColor = colors[0];

    const userId = Math.random().toString(36).substr(2, 9); // Voeg deze regel toe

    let grid = {};
    let activeUsers = {};
    let scale = 1, offsetX = 0, offsetY = 0;
    let isPanning = false, startX, startY;
    let cooldownActive = false;

    // Canvas grootte instellen
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Start Overlay Verwijderen
    startButton.addEventListener('click', () => {
      startOverlay.style.display = 'none';
    });

    // Cooldown Indicator
    const startCooldown = (seconds) => {
  cooldownActive = true;
  cooldownIndicator.style.display = 'block';
  cooldownIndicator.textContent = `Cooldown: ${seconds}s`;
  let remaining = seconds;

  const interval = setInterval(() => {
    remaining--;
    cooldownIndicator.textContent = `Cooldown: ${remaining}s`;

    if (remaining <= 0) {
      clearInterval(interval);
      cooldownIndicator.style.display = 'none';
      cooldownActive = false;
    }
  }, 1000);
};


    // Grid tekenen
    const drawGrid = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }

      // Teken pixels
      Object.entries(grid).forEach(([key, color]) => {
        const [x, y] = key.split(',').map(Number);
        ctx.fillStyle = color;
        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
      });

      // Teken actieve muisindicaties
      Object.values(activeUsers).forEach(({ x, y }) => {
        ctx.beginPath();
        ctx.arc(x, y, 5 / scale, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fill();
      });

      ctx.restore();
    };

    drawGrid();

    // WebSocket handlers
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'init') {
        grid = data.grid;
        drawGrid();
      } else if (data.type === 'update_pixel') {
        const { x, y, color } = data;
        grid[`${x},${y}`] = color;
        drawGrid();
      } else if (data.type === 'mouse_move') {
        activeUsers[data.userId] = { x: data.x / scale - offsetX / scale, y: data.y / scale - offsetY / scale };
        drawGrid();
      }
    };

    // Plaats pixel
    canvas.addEventListener('click', (e) => {
  if (cooldownActive) return; // Blokkeer als de cooldown actief is

  const x = Math.floor((e.clientX - offsetX) / (cellSize * scale));
  const y = Math.floor((e.clientY - offsetY) / (cellSize * scale));

  // Verzend pixelplaatsing naar de server
  socket.send(JSON.stringify({
    type: 'place_pixel',
    userId,
    x,
    y,
    color: selectedColor,
  }));

  // Voeg de pixel lokaal toe aan de grid
  grid[`${x},${y}`] = selectedColor;
  drawGrid();

  // Start de cooldown-timer
  startCooldown(30);
});

// Voor touch ondersteuning
let lastTouchDistance = null;

canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    isPanning = true;
    startX = e.touches[0].clientX - offsetX;
    startY = e.touches[0].clientY - offsetY;
  } else if (e.touches.length === 2) {
    lastTouchDistance = getTouchDistance(e);
  }
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault(); // Voorkomt scrollen op mobiel
  if (e.touches.length === 1 && isPanning) {
    const touch = e.touches[0];
    offsetX = touch.clientX - startX;
    offsetY = touch.clientY - startY;
    drawGrid();
  } else if (e.touches.length === 2) {
    const newDistance = getTouchDistance(e);
    if (lastTouchDistance) {
      const delta = newDistance / lastTouchDistance;
      scale *= delta;
      scale = Math.min(Math.max(0.5, scale), 10); // Beperk de zoomfactor
      lastTouchDistance = newDistance;
      drawGrid();
    }
  }
});

canvas.addEventListener('touchend', (e) => {
  if (e.touches.length < 2) {
    lastTouchDistance = null;
  }
  isPanning = false;
});

// Helper functie om afstand tussen twee aanrakingen te berekenen
function getTouchDistance(e) {
  const dx = e.touches[0].clientX - e.touches[1].clientX;
  const dy = e.touches[0].clientY - e.touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// Responsive canvas aanpassen bij schermgrootte
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  drawGrid();
});



    // Muis beweging
    canvas.addEventListener('mousemove', (event) => {
      if (isPanning) {
        offsetX = event.clientX - startX;
        offsetY = event.clientY - startY;
        drawGrid();
      } else {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        socket.send(JSON.stringify({ type: 'move_mouse', userId, x, y }));
      }
    });

    canvas.addEventListener('mousedown', (event) => {
      isPanning = true;
      startX = event.clientX - offsetX;
      startY = event.clientY - offsetY;
    });

    canvas.addEventListener('mouseup', () => {
      isPanning = false;
    });

    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();
      scale += event.deltaY * -0.001;
      scale = Math.min(Math.max(0.5, scale), 4);
      drawGrid();
    });

    // Color picker
    const colorPicker = document.getElementById('color-picker');
    colors.forEach((color) => {
      const div = document.createElement('div');
      div.className = 'color';
      div.style.backgroundColor = color;

      if (color === selectedColor) div.classList.add('selected');

      div.addEventListener('click', () => {
        document.querySelectorAll('.color').forEach((el) => el.classList.remove('selected'));
        div.classList.add('selected');
        selectedColor = color;
      });

      colorPicker.appendChild(div);
    });
  </script>
</body>
</html>
