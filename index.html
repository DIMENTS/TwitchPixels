<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Twitch /Place - Community Pixel Art</title>
  <link rel="icon" href="/twitchpixelsico.png" type="image/x-icon">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #canvas {
      display: block;
      cursor: crosshair;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      max-width: 100vw;
      max-height: 100vh;
      margin: auto; /* Centeert het canvas */
    }

    #color-picker {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .color {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      border: 1px solid #c4c4c4; /* Light grey border */
      transition: border 0.2s;
    }

    .color:hover,
    .color.selected {
      border-color: black;
    }

    #start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      text-align: center; /* Center de tekst horizontaal */
    }

    #start-overlay h1 {
      font-size: 2em;
      margin-bottom: 20px;
    }

    .twitch-purple {
      color: #9146FF; /* Twitch paars */
    }

    .place-offwhite {
      color: #F5F5F5; /* Off-white / bijna wit */
    }

    #start-overlay p {
      font-size: 1.2em;
      margin-bottom: 40px;
      padding: 0 20px;
      max-width: 840px; /* Maximale breedte van de tekst */
      line-height: 1.5; /* Voor betere leesbaarheid */
    }

    #start-overlay button {
      padding: 15px 30px; /* Iets grotere padding */
      font-size: 1.2em;
      background: #F5F5F5; /* Off-white achtergrond */
      color: black; /* Zwarte tekst voor contrast */
      border: none;
      border-radius: 50px; /* Ronde knop */
      cursor: pointer;
      transition: background-color 0.3s ease; /* Soepele overgang bij hover */
    }

    #start-overlay button:hover {
      background: #E0E0E0; /* Iets donkerder off-white bij hover */
    }

    #cooldown-indicator {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 1.2em;
      display: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="color-picker"></div>

  <div id="start-overlay">
    <h1>
      <span class="twitch-purple">Twitch</span>
      <span class="place-offwhite">/Place</span>!
    </h1>
    <p>
      Klik op een pixel om een kleur te plaatsen. Je moet 30 seconden wachten voordat je weer een pixel kunt plaatsen.
      Gebruik je muis of pijltjestoetsen om over de grid te navigeren. Zoom in en uit met je scrollwheel.
    </p>
    <button id="start-button">Start</button>
  </div>

  <div id="cooldown-indicator">Cooldown: 30s</div>

  <script>
  const socket = new WebSocket('wss://tpwebsocket-production.up.railway.app');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const startOverlay = document.getElementById('start-overlay');
  const startButton = document.getElementById('start-button');
  const overlayShownKey = 'startOverlayShown';
  const cooldownIndicator = document.getElementById('cooldown-indicator');
  const gridSize = 500; // Afmeting van het tekengebied (aantal cellen)
  const cellSize = 10;
  const colors = ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#800000', '#00008B', '#FFFF00'];
  let selectedColor = colors[0];
  let grid = {};
  let activeUsers = {};
  let scale = 1, offsetX = 0, offsetY = 0;
  let isPanning = false, startX, startY;
  let cooldownActive = false;

  // Zorg ervoor dat het canvas de volledige grootte van het venster gebruikt
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Center grid initially
  offsetX = (canvas.width - gridSize * cellSize) / 2;
  offsetY = (canvas.height - gridSize * cellSize) / 2;

  // Teken de grid
  const drawGrid = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    // Teken de basisgrid
    for (let x = 0; x < gridSize; x++) {
      for (let y = 0; y < gridSize; y++) {
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
      }
    }

    // Teken de pixels
    Object.entries(grid).forEach(([key, color]) => {
      const [x, y] = key.split(',').map(Number);
      ctx.fillStyle = color;
      ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
    });

    ctx.restore();
  };

  // Voer initieel tekenen uit
  drawGrid();

  // Startknop functionaliteit
  startButton.addEventListener('click', () => {
    startOverlay.style.display = 'none'; // Verberg de overlay
    localStorage.setItem(overlayShownKey, 'true'); // Sla op dat de overlay is getoond
  });

  // Controleer of de overlay al eerder is getoond
  if (localStorage.getItem(overlayShownKey) === 'true') {
    startOverlay.style.display = 'none'; // Verberg de overlay als deze al eerder is getoond
  }

  // Functie om te zoomen
  canvas.addEventListener('wheel', (event) => {
    event.preventDefault();

    const zoomFactor = 1.05;
    const mouseX = (event.clientX - offsetX) / scale;
    const mouseY = (event.clientY - offsetY) / scale;

    if (event.deltaY < 0) scale *= zoomFactor; // Zoom in
    else scale /= zoomFactor; // Zoom uit

    offsetX = event.clientX - mouseX * scale;
    offsetY = event.clientY - mouseY * scale;

    drawGrid();
  });

  // Andere functies voor interactie
  canvas.addEventListener('mousedown', (event) => {
    isPanning = true;
    startX = event.clientX;
    startY = event.clientY;
  });

  canvas.addEventListener('mousemove', (event) => {
    if (isPanning) {
      offsetX += event.clientX - startX;
      offsetY += event.clientY - startY;
      startX = event.clientX;
      startY = event.clientY;
      drawGrid();
    }
  });

  canvas.addEventListener('mouseup', () => {
    isPanning = false;
  });

  canvas.addEventListener('mouseleave', () => {
    isPanning = false;
  });

  // Voeg kleuren toe aan de color picker
  const colorPicker = document.getElementById('color-picker');
  colors.forEach((color) => {
    const colorDiv = document.createElement('div');
    colorDiv.classList.add('color');
    colorDiv.style.backgroundColor = color;
    colorDiv.addEventListener('click', () => {
      document.querySelectorAll('.color').forEach(c => c.classList.remove('selected'));
      colorDiv.classList.add('selected');
      selectedColor = color;
    });
    colorPicker.appendChild(colorDiv);
  });

  // WebSocket interactie
  socket.addEventListener('open', () => {
    console.log('Connected to WebSocket server');
  });

  socket.addEventListener('message', (event) => {
    const data = JSON.parse(event.data);
    if (data.type === 'update') {
      grid[data.pixel] = data.color;
      drawGrid();
    }
  });

  canvas.addEventListener('click', (event) => {
    if (cooldownActive) return;

    const x = Math.floor((event.clientX - offsetX) / (scale * cellSize));
    const y = Math.floor((event.clientY - offsetY) / (scale * cellSize));
    const pixel = `${x},${y}`;

    grid[pixel] = selectedColor;
    drawGrid();

    socket.send(JSON.stringify({ type: 'place', pixel, color: selectedColor }));

    // Start cooldown
    cooldownActive = true;
    cooldownIndicator.style.display = 'block';
    let cooldownTime = 30;
    const cooldownInterval = setInterval(() => {
      cooldownTime--;
      cooldownIndicator.textContent = `Cooldown: ${cooldownTime}s`;
      if (cooldownTime <= 0) {
        clearInterval(cooldownInterval);
        cooldownIndicator.style.display = 'none';
        cooldownActive = false;
      }
    }, 1000);
  });
</script>
</body>
</html>
