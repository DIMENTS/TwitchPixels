<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Twitch /Place - Community Pixel Art</title>
  <link rel="icon" href="/twitchpixelsico.png" type="image/x-icon">  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #canvas {
    display: block;
    cursor: crosshair;
    background-color: #c4c4c4; /* Achtergrondkleur */
    box-sizing: border-box;
    max-width: 100vw;
    max-height: 100vh;
    margin: auto; /* Centeert het canvas */
    }


    #color-picker {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .color {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  cursor: pointer;
  border: 1px solid #c4c4c4; /* Light grey border */
  transition: border 0.2s;
}

    .color:hover,
    .color.selected {
      border-color: black;
    }

    #start-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10;
    text-align: center; /* Center de tekst horizontaal */
}

    #start-overlay h1 {
    font-size: 2em;
    margin-bottom: 20px;
}

    .twitch-purple {
    color: #9146FF; /* Twitch paars */
}

.place-offwhite {
    color: #F5F5F5; /* Off-white / bijna wit */
}

#start-overlay p {
    font-size: 1.2em;
    margin-bottom: 40px;
    padding: 0 20px;
    max-width: 840px; /* Maximale breedte van de tekst */
    line-height: 1.5; /* Voor betere leesbaarheid */
}

    #start-overlay button {
    padding: 15px 30px; /* Iets grotere padding */
    font-size: 1.2em;
    background: #F5F5F5; /* Off-white achtergrond */
    color: black; /* Zwarte tekst voor contrast */
    border: none;
    border-radius: 50px; /* Ronde knop */
    cursor: pointer;
    transition: background-color 0.3s ease; /* Soepele overgang bij hover */
}

#start-overlay button:hover {
    background: #E0E0E0; /* Iets donkerder off-white bij hover */
}

    #cooldown-indicator {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 1.2em;
      display: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="color-picker"></div>

  <div id="start-overlay">
    <h1>
        <span class="twitch-purple">Twitch</span>
        <span class="place-offwhite">/Place</span>!
    </h1>
    <p>
        Klik op een pixel om een kleur te plaatsen. Je moet 30 seconden wachten voordat je weer een pixel kunt plaatsen.
        Gebruik je muis of pijltjestoetsen om over de grid te navigeren. Zoom in en uit met je scrollwheel.
    </p>
    <button id="start-button">Start</button>
</div>

  <div id="cooldown-indicator">Cooldown: 30s</div>

  <script>
    const socket = new WebSocket('wss://tpwebsocket-production.up.railway.app');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startOverlay = document.getElementById('start-overlay');
    const startButton = document.getElementById('start-button');
    const overlayShownKey = 'startOverlayShown';
    const cooldownIndicator = document.getElementById('cooldown-indicator');
    const gridSize = 500; // Afmeting van het tekengebied (aantal cellen)
    const cellSize = 10;
    const canvasBorder = 2;

    const colors = [
        '#000000', '#FFFFFF', '#FF0000', '#00FF00',
        '#0000FF', '#800000', '#00008B', '#FFFF00'
    ];
    let selectedColor = colors[0];
    const userId = Math.random().toString(36).substr(2, 9);
    let grid = {};
    let activeUsers = {};
    let scale = 1, offsetX = 0, offsetY = 0;
    let isPanning = false, startX, startY;
    let cooldownActive = false;

    // Bereken canvas-grootte en centreren
    const calculateCanvasDimensions = () => {
        canvas.width = Math.min(gridSize * cellSize + 2 * canvasBorder, window.innerWidth);
        canvas.height = Math.min(gridSize * cellSize + 2 * canvasBorder, window.innerHeight);
        offsetX = (canvas.width - gridSize * cellSize * scale) / 2;
        offsetY = (canvas.height - gridSize * cellSize * scale) / 2;
        offsetX = Math.max(0, offsetX);
        offsetY = Math.max(0, offsetY);
    };
    calculateCanvasDimensions();

    // Overlay functionaliteit
    startButton.addEventListener('click', () => {
        startOverlay.style.display = 'none';
        localStorage.setItem(overlayShownKey, 'true');
    });

    if (localStorage.getItem(overlayShownKey) === 'true') {
        startOverlay.style.display = 'none';
    }

    // Cooldown
    const startCooldown = (seconds) => {
        cooldownActive = true;
        cooldownIndicator.style.display = 'block';
        cooldownIndicator.textContent = `Cooldown: ${seconds}s`;
        let remaining = seconds;
        const interval = setInterval(() => {
            remaining--;
            cooldownIndicator.textContent = `Cooldown: ${remaining}s`;
            if (remaining <= 0) {
                clearInterval(interval);
                cooldownIndicator.style.display = 'none';
                cooldownActive = false;
            }
        }, 1000);
    };

    // Grid tekenen
    const drawGrid = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

        // Teken raster
        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
        }

        // Teken pixels
        Object.entries(grid).forEach(([key, color]) => {
            const [x, y] = key.split(',').map(Number);
            ctx.fillStyle = color;
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        });

        // Teken actieve gebruikers
        Object.values(activeUsers).forEach(({ x, y }) => {
            ctx.beginPath();
            ctx.arc(x, y, 5 / scale, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fill();
        });

        ctx.restore();
    };

    drawGrid();

    // WebSocket handlers
    socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'init') {
            grid = data.grid;
            drawGrid();
        } else if (data.type === 'update_pixel') {
            const { x, y, color } = data;
            grid[`${x},${y}`] = color;
            drawGrid();
        } else if (data.type === 'mouse_move') {
            activeUsers[data.userId] = {
                x: data.x / scale - offsetX / scale,
                y: data.y / scale - offsetY / scale,
            };
            drawGrid();
        }
    };

    // Pixel plaatsen
    canvas.addEventListener('click', (e) => {
    if (cooldownActive) return;
    
    // Bereken de cell-coördinaten
    const x = Math.floor((e.clientX - offsetX) / (cellSize * scale));
    const y = Math.floor((e.clientY - offsetY) / (cellSize * scale));
    
    // Controleer of de coördinaten binnen het grid vallen
    if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) {
    alert('Je kunt hier geen pixels plaatsen! Kies een plek binnen het raster.');
    return;
    }

    // Verstuur de pixel-update naar de server
    socket.send(JSON.stringify({ type: 'place_pixel', userId, x, y, color: selectedColor }));
    grid[`${x},${y}`] = selectedColor;
    drawGrid();
    startCooldown(30);
    });


    // Zoom en Pan
    canvas.addEventListener('wheel', (event) => {
        event.preventDefault();
        const prevScale = scale;
        scale += event.deltaY * -0.001;
        scale = Math.min(Math.max(0.5, scale), 4);
        const zoomFactor = scale / prevScale;
        offsetX = (offsetX - event.clientX) * zoomFactor + event.clientX;
        offsetY = (offsetY - event.clientY) * zoomFactor + event.clientY;
        drawGrid();
    });

    canvas.addEventListener('mousedown', (event) => {
        isPanning = true;
        startX = event.clientX - offsetX;
        startY = event.clientY - offsetY;
    });

    canvas.addEventListener('mousemove', (event) => {
        if (isPanning) {
            offsetX = event.clientX - startX;
            offsetY = event.clientY - startY;
            drawGrid();
        } else {
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left - offsetX) / scale;
            const y = (event.clientY - rect.top - offsetY) / scale;
            socket.send(JSON.stringify({ type: 'move_mouse', userId, x, y }));
        }
    });

    canvas.addEventListener('mouseup', () => {
        isPanning = false;
    });

    // Kleuren selecteren
    const colorPicker = document.getElementById('color-picker');
    colors.forEach((color) => {
        const div = document.createElement('div');
        div.className = 'color';
        div.style.backgroundColor = color;
        if (color === selectedColor) div.classList.add('selected');
        div.addEventListener('click', () => {
            document.querySelectorAll('.color').forEach((el) => el.classList.remove('selected'));
            div.classList.add('selected');
            selectedColor = color;
        });
        colorPicker.appendChild(div);
    });
</script>
</body>
</html>
