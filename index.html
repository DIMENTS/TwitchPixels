<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Twitch /Place - Community Pixel Art</title>
  <link rel="icon" href="/twitchpixelsico.png" type="image/x-icon">  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #canvas {
    display: block;
    cursor: crosshair;
    background-color: #c4c4c4; /* Achtergrondkleur */
    box-sizing: border-box;
    max-width: 100vw;
    max-height: 100vh;
    margin: auto; /* Centeert het canvas */
    }


    #color-picker {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .color {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  cursor: pointer;
  border: 1px solid #c4c4c4; /* Light grey border */
  transition: border 0.2s;
}

    .color:hover,
    .color.selected {
      border-color: black;
    }

    #start-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10;
    text-align: center; /* Center de tekst horizontaal */
}

    #start-overlay h1 {
    font-size: 2em;
    margin-bottom: 20px;
}

    .twitch-purple {
    color: #9146FF; /* Twitch paars */
}

.place-offwhite {
    color: #F5F5F5; /* Off-white / bijna wit */
}

#start-overlay p {
    font-size: 1.2em;
    margin-bottom: 40px;
    padding: 0 20px;
    max-width: 840px; /* Maximale breedte van de tekst */
    line-height: 1.5; /* Voor betere leesbaarheid */
}

    #start-overlay button {
    padding: 15px 30px; /* Iets grotere padding */
    font-size: 1.2em;
    background: #F5F5F5; /* Off-white achtergrond */
    color: black; /* Zwarte tekst voor contrast */
    border: none;
    border-radius: 50px; /* Ronde knop */
    cursor: pointer;
    transition: background-color 0.3s ease; /* Soepele overgang bij hover */
}

#start-overlay button:hover {
    background: #E0E0E0; /* Iets donkerder off-white bij hover */
}

    #controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin-bottom: 40px;
}

.control {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 1.2em;
}

.control img {
    width: 40px;
    height: 40px;
}

.control.touch {
    display: none; /* Verberg voor desktop */
}

/* Toon touch-specific controls op mobiele apparaten */
@media (hover: none) and (pointer: coarse) {
    .control.touch {
        display: flex;
    }

    .control:not(.touch) {
        display: none; /* Verberg desktop controls */
    }
}


    #cooldown-indicator {
  position: fixed;
  bottom: 80px; /* Plaatsing net boven de color picker */
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 0, 0, 0.8); /* Roodachtige achtergrond */
  color: white; /* Witte tekst */
  padding: 10px 20px;
  border-radius: 5px;
  font-size: 1.2em;
  display: none;
  z-index: 10;
  text-align: center; /* Centraal uitlijnen */
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); /* Schaduw voor zichtbaarheid */
}

  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="color-picker"></div>

  <div id="start-overlay">
    <h1>
        <span class="twitch-purple">Twitch</span>
        <span class="place-offwhite">/Place</span>!
    </h1>
    <p>
        Klik op een pixel om een kleur te plaatsen. Je moet 30 seconden wachten voordat je weer een pixel kunt plaatsen.
    </p>

    <!-- Controls sectie -->
    <div id="controls">
        <div class="control">
            <img src="/icons/scrolldrag.png" alt="Scrollwheel Click" />
            <span>Houd Scrollwheel ingedrukt om te bewegen.</span>
        </div>
        <div class="control">
            <img src="/icons/scrollwheel.png" alt="Scroll wheel" />
            <span>Zoom in en uit met je scrollwheel.</span>
        </div>
        <div class="control">
            <img src="/icons/leftclick.png" alt="Mouse click" />
            <span>Klik om een pixel te plaatsen.</span>
        </div>
        <div class="control touch">
            <img src="/icons/touchgesture.png" alt="Touch gestures" />
            <span>Swipe om te bewegen en pinch om te zoomen</span>
        </div>
    </div>

    <button id="start-button">Start</button>
</div>


  <div id="cooldown-indicator">Cooldown: 30s</div>

  <script>
    const socket = new WebSocket('wss://tpwebsocket-production.up.railway.app');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startOverlay = document.getElementById('start-overlay');
    const startButton = document.getElementById('start-button');
    const overlayShownKey = 'startOverlayShown';
    const cooldownIndicator = document.getElementById('cooldown-indicator');
    const gridSize = 1000; // Afmeting van het tekengebied (aantal cellen)
    const cellSize = 10;
    const canvasBorder = 2;

    const colors = [
        '#000000', '#c4c4c4', '#2351a5', '#ff4500',
        '#FFFF00', '#008C45'
    ];
    let selectedColor = colors[0];
    const userId = Math.random().toString(36).substr(2, 9);
    let grid = {};
    let activeUsers = {};
    let scale = 1, offsetX = 0, offsetY = 0;
    let isPanning = false, startX, startY;
    let cooldownActive = false;

    // Pinch-to-zoom en touch-movement variabelen
    let isDragging = false;
    let isPinching = false;
    let lastTouchX = 0;
    let lastTouchY = 0;
    let initialDistance = 0;

    // Bereken canvas-grootte en centreren
    const calculateCanvasDimensions = () => {
        canvas.width = Math.min(gridSize * cellSize + 2 * canvasBorder, window.innerWidth);
        canvas.height = Math.min(gridSize * cellSize + 2 * canvasBorder, window.innerHeight);
        offsetX = (canvas.width - gridSize * cellSize * scale) / 2;
        offsetY = (canvas.height - gridSize * cellSize * scale) / 2;
        offsetX = Math.max(0, offsetX);
        offsetY = Math.max(0, offsetY);
    };
    calculateCanvasDimensions();

    // Overlay functionaliteit
    startButton.addEventListener('click', () => {
        startOverlay.style.display = 'none';
        localStorage.setItem(overlayShownKey, 'true');
    });

    if (localStorage.getItem(overlayShownKey) === 'true') {
        startOverlay.style.display = 'none';
    }

    // Cooldown
    const startCooldown = (seconds) => {
    cooldownActive = true;
    const startTime = Date.now();
    const endTime = startTime + seconds * 1000;

    const updateCooldown = () => {
        const now = Date.now();
        const remaining = Math.ceil((endTime - now) / 1000);
        cooldownIndicator.textContent = `Cooldown: ${remaining}s`;

        if (remaining > 0) {
            requestAnimationFrame(updateCooldown);
        } else {
            cooldownIndicator.style.display = 'none';
            cooldownActive = false;
        }
    };

    cooldownIndicator.style.display = 'block';
    requestAnimationFrame(updateCooldown);
};


    // Grid tekenen
    const drawGrid = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

    // Bereken zichtbare cellen
    const startX = Math.max(0, Math.floor(-offsetX / cellSize / scale));
    const endX = Math.min(gridSize, Math.ceil((canvas.width - offsetX) / cellSize / scale));
    const startY = Math.max(0, Math.floor(-offsetY / cellSize / scale));
    const endY = Math.min(gridSize, Math.ceil((canvas.height - offsetY) / cellSize / scale));

    for (let x = startX; x < endX; x++) {
        for (let y = startY; y < endY; y++) {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
    }

    Object.entries(grid).forEach(([key, color]) => {
        const [x, y] = key.split(',').map(Number);
        if (x >= startX && x < endX && y >= startY && y < endY) {
            ctx.fillStyle = color;
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
    });

    ctx.restore();
};


    drawGrid();
    

    // WebSocket handlers
    socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'init') {
            grid = data.grid;
            drawGrid();
        } else if (data.type === 'update_pixel') {
            const { x, y, color } = data;
            grid[`${x},${y}`] = color;
            drawGrid();
        } else if (data.type === 'mouse_move') {
            activeUsers[data.userId] = {
                x: data.x / scale - offsetX / scale,
                y: data.y / scale - offsetY / scale,
            };
            drawGrid();
        }
    };

    function placePixel(clientX, clientY) {
    if (cooldownActive) return;

    // Bereken de cell-coördinaten
    const x = Math.floor((clientX - offsetX) / (cellSize * scale));
    const y = Math.floor((clientY - offsetY) / (cellSize * scale));

    // Controleer of de coördinaten binnen het grid vallen
    if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) {
        alert('Je kunt hier geen pixels plaatsen! Kies een plek binnen het raster.');
        return;
    }

    // Verstuur de pixel-update naar de server
      socket.send(JSON.stringify({ type: 'place_pixel', userId, x, y, color: selectedColor }));
      grid[`${x},${y}`] = selectedColor;
      drawGrid();
      startCooldown(30);
    }

      canvas.addEventListener('click', (e) => {
      placePixel(e.clientX, e.clientY);
    });

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            isDragging = true;
            lastTouchX = e.touches[0].clientX;
            lastTouchY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            isPinching = true;
            initialDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
        }
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (isDragging && !isPinching) {
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            offsetX += (currentX - lastTouchX) / scale;
            offsetY += (currentY - lastTouchY) / scale;
            lastTouchX = currentX;
            lastTouchY = currentY;
            drawGrid();
        } else if (isPinching && e.touches.length === 2) {
            const currentDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            const zoomFactor = currentDistance / initialDistance;
            scale = Math.min(Math.max(0.5, scale * zoomFactor), 4);
            initialDistance = currentDistance;
            drawGrid();
        }
    });

    canvas.addEventListener('touchend', (e) => {
        if (e.touches.length === 0) {
            isDragging = false;
            isPinching = false;
        }
    });

    // Zoom en Pan
    canvas.addEventListener('wheel', (event) => {
        event.preventDefault();
        const prevScale = scale;
        scale += event.deltaY * -0.001;
        scale = Math.min(Math.max(0.5, scale), 4);
        const zoomFactor = scale / prevScale;
        offsetX = (offsetX - event.clientX) * zoomFactor + event.clientX;
        offsetY = (offsetY - event.clientY) * zoomFactor + event.clientY;
        drawGrid();
    });

    canvas.addEventListener('mousedown', (event) => {
        isPanning = true;
        startX = event.clientX - offsetX;
        startY = event.clientY - offsetY;
    });

    canvas.addEventListener('mousemove', (event) => {
        if (isPanning) {
            offsetX = event.clientX - startX;
            offsetY = event.clientY - startY;
            drawGrid();
        } else {
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left - offsetX) / scale;
            const y = (event.clientY - rect.top - offsetY) / scale;
            socket.send(JSON.stringify({ type: 'move_mouse', userId, x, y }));
        }
    });

    canvas.addEventListener('mouseup', () => {
        isPanning = false;
    });

    // Kleuren selecteren
    const colorPicker = document.getElementById('color-picker');
    colors.forEach((color) => {
        const div = document.createElement('div');
        div.className = 'color';
        div.style.backgroundColor = color;
        if (color === selectedColor) div.classList.add('selected');
        div.addEventListener('click', () => {
            document.querySelectorAll('.color').forEach((el) => el.classList.remove('selected'));
            div.classList.add('selected');
            selectedColor = color;
        });
        colorPicker.appendChild(div);
    });
</script>
</body>
</html>
